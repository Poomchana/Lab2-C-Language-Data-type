คำถาม

2.
2.1 สังเกตผลจากการรันโคิดในส่วน 2.1 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า 100 อยู่ในช่วงที่ int สามารถเก็บได้ จึงแสดงผลถูกต้อง การกำหนดค่าตัวเลขให้กับตัวแปรตรงตามหลักการพื้นฐานของการกำหนดค่าในคณิตศาสตร์

2.2 สังเกตผลจากการรันโคิดในส่วน 2.2 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า 2,147,483,647 เป็นค่าสูงสุดของ int (32-bit signed integer) ซึ่งยังอยู่ในขอบเขตที่ชนิดข้อมูลนี้สามารถจัดเก็บได้พอดี ทำให้ไม่มีการเปลี่ยนแปลงหรือผิดเพี้ยนจากค่าที่กำหนด

2.3 สังเกตผลจากการรันโคิดในส่วน 2.3 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ไม่ตรงตามหลักการทางคณิตศาสตร์ปกติ
เหตุผล: เกิด Integer Overflow เมื่อค่าเกินขีดจำกัดสูงสุดของ int (2,147,483,647 + 1) ทำให้ค่าที่คำนวณได้วนกลับไปเป็นค่าต่ำสุดของ int (-2,147,483,648) แทนที่จะเป็น 2,147,483,648 ตามหลักคณิตศาสตร์

2.4 สังเกตผลจากการรันโคิดในส่วน 2.4 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ตรงตามหลักการทางคณิตศาสตร์
เหตุผล: ค่า -2,147,483,648 เป็นค่าต่ำสุดของ int (32-bit signed integer) ซึ่งยังอยู่ในขอบเขตที่ชนิดข้อมูลนี้สามารถจัดเก็บได้พอดี ทำให้ไม่มีการเปลี่ยนแปลงจากค่าที่กำหนด

2.5 สังเกตผลจากการรันโคิดในส่วน 2.5 ว่าตรงตามหลักการทางคณิตศาสตร์หรือไม่ เพราะเหตุใด
ไม่ตรงตามหลักการทางคณิตศาสตร์ปกติ
เหตุผล: เกิด Integer Underflow เมื่อค่าต่ำกว่าขีดจำกัดต่ำสุดของ int (-2,147,483,648 - 1) ทำให้ค่าที่คำนวณได้วนกลับไปเป็นค่าสูงสุดของ int (2,147,483,647) แทนที่จะเป็น -2,147,483,649 ตามหลักคณิตศาสตร์

3.
3.1 คุณสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร?
-float: ใช้ 32 บิต (Single Precision) ซึ่งให้ความแม่นยำประมาณ 6-7 ตำแหน่งทศนิยม
-double บน ESP32: แม้ว่าในคอมพิวเตอร์ทั่วไป double จะหมายถึง 64 บิต (Double Precision) แต่บน ESP32 (และไมโครคอนโทรลเลอร์ 32 บิตหลายตัว) double มักจะถูกนำมาใช้โดยมีขนาดและความแม่นยำเท่ากับ float (คือ 32 บิต) นั่นหมายความว่ามันก็ให้ความแม่นยำประมาณ 6-7 ตำแหน่งทศนิยม เช่นกันครับ

3.2 สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
-ความเข้ากันได้ของโค้ด (Code Portability): หากโค้ดที่คุณเขียนอาจจะต้องถูกนำไปใช้บนแพลตฟอร์มอื่นในอนาคต (เช่น คอมพิวเตอร์ตั้งโต๊ะ) ที่ double เป็น 64 บิตจริงและให้ความแม่นยำสูงกว่า การใช้ double ตั้งแต่แรกจะช่วยให้โค้ดของคุณพร้อมสำหรับการพอร์ตย้ายได้ง่ายขึ้น โดยไม่ต้องกลับมาแก้ไขชนิดข้อมูลในภายหลัง
-ความชัดเจนในการเขียนโค้ด (Code Clarity/Intent): การใช้ double อาจเป็นการระบุเจตนาของคุณว่าการคำนวณนั้นๆ ต้องการความแม่นยำสูง หรือเกี่ยวข้องกับค่าทศนิยมที่ละเอียดมากๆ ซึ่งช่วยให้ผู้อื่นที่อ่านโค้ดเข้าใจจุดประสงค์ได้ชัดเจน แม้ว่าตัวฮาร์ดแวร์ ESP32 จะไม่ได้รองรับความแม่นยำนั้นก็ตาม

4.
4.1 ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
ค่าตัวเลข (ASCII value) คือรหัสที่เป็นตัวเลขที่ใช้แทน อักขระ แต่ละตัวในคอมพิวเตอร์
คอมพิวเตอร์จะเข้าใจเฉพาะตัวเลขเท่านั้น ดังนั้น ASCII (และมาตรฐานอื่นๆ เช่น Unicode) จึงถูกสร้างขึ้นมาเพื่อกำหนดว่าอักขระแต่ละตัว (เช่น 'A', 'z', '!', '$') จะมีค่าตัวเลขเฉพาะเจาะจง (รหัส ASCII) อะไร เช่น 'A' มีค่า ASCII คือ 65 หรือ 'z' มีค่า ASCII คือ 122
ดังนั้น ตัวแปร char จะเก็บค่าตัวเลข ASCII นี้ไว้ และเมื่อเราสั่งให้แสดงผล ระบบก็จะแปลงค่าตัวเลขนั้นกลับไปเป็นอักขระที่สอดคล้องกัน

4.2 ถ้าอยากทราบความสัมพันธ์ระหว่างตัวเลขกับอักขระทั้งหมด สามารถหาได้จากเอกสารใด หรือแหล่งอ้างอิงใด
-ASCII Table (ตารางแอสกี): ใช้สำหรับอักขระภาษาอังกฤษและสัญลักษณ์พื้นฐาน (ค่า 0-127) คุณสามารถค้นหา "ASCII table" ใน Google ได้เลย จะมีตารางแสดงให้เห็นอย่างชัดเจนพร้อมค่าในรูปแบบฐานสิบ, ฐานสิบหก, และฐานสอง.
-Unicode Standard (มาตรฐานยูนิโค้ด): เป็นมาตรฐานที่ครอบคลุมอักขระจากภาษาทั่วโลก รวมถึงอีโมจิและสัญลักษณ์ต่างๆ คุณสามารถหาข้อมูลเพิ่มเติมได้ที่เว็บไซต์ทางการของ Unicode Consortium: www.unicode.org ที่นั่นจะมีตารางรหัส (Code Charts) สำหรับแต่ละช่วงภาษา.
-Character Encoding (การเข้ารหัสอักขระ) เช่น UTF-8: เป็นวิธีการแปลงรหัสตัวเลขของอักขระ (เช่น Unicode code points) ให้เป็นลำดับของไบต์ที่คอมพิวเตอร์จัดเก็บและส่งผ่านได้ UTF-8 เป็นที่นิยมมากที่สุดเพราะสามารถรองรับ Unicode ได้ทั้งหมดและเข้ากันได้กับ ASCII. คุณสามารถหาบทความอธิบายเกี่ยวกับ UTF-8 ได้จากแหล่งความรู้ด้านคอมพิวเตอร์ทั่วไป.

4.3 จากข้อ 4.2 นักเขียนโปรแกรมสามารถกำหนดขึ้นเองได้ หรือมีเอกสารใดกำกับอยู่
นักเขียนโปรแกรมไม่สามารถกำหนดความสัมพันธ์ระหว่างค่าตัวเลขและอักขระขึ้นมาเองได้
ความสัมพันธ์นี้ มีเอกสารมาตรฐานสากลกำกับไว้อย่างชัดเจน เช่น ASCII และ Unicode เพื่อให้แน่ใจว่าระบบคอมพิวเตอร์ทั่วโลกสามารถสื่อสารและแสดงผลอักขระได้อย่างถูกต้องและสอดคล้องกัน หากแต่ละคนกำหนดรหัสขึ้นมาเอง การแลกเปลี่ยนข้อมูลที่เป็นข้อความระหว่างระบบต่างๆ ก็จะเป็นไปไม่ได้

5.
5.1 true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
บน Serial Monitor:
true จะถูกแสดงผลเป็น 1
false จะถูกแสดงผลเป็น 0
นี่เป็นเพราะในภาษา C++ (ซึ่ง Arduino ใช้) ค่า Boolean มักจะถูกแปลงเป็นค่าจำนวนเต็มเมื่อจำเป็นต้องแสดงผลในรูปแบบตัวเลข โดย true ถูกแทนด้วย 1 และ false ถูกแทนด้วย 0 
6.
6.1 บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่?
บน ESP32, ชนิดข้อมูล long มีขอบเขต เท่ากับ int
ทั้ง int และ long บน ESP32 (ซึ่งเป็นสถาปัตยกรรม 32 บิต) มักจะมีขนาด 32 บิตเท่ากัน
ดังนั้น ช่วงค่าของทั้งคู่คือ -2,147,483,648 ถึง 2,147,483,647

6.2 ชนิดข้อมูลใดที่ต้องใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุดบน ESP32 ควรใช้ชนิดข้อมูล:
unsigned long long
นี่คือเหตุผล:
unsigned: หมายถึง "ไม่มีเครื่องหมาย" (non-signed) ซึ่งอนุญาตให้เก็บเฉพาะค่าบวกเท่านั้น ทำให้ขอบเขตสูงสุดเพิ่มขึ้นเป็นสองเท่าของชนิดข้อมูลแบบมีเครื่องหมายที่มีขนาดเท่ากัน
long long: เป็นชนิดข้อมูลจำนวนเต็มที่มีขนาดใหญ่ที่สุดที่รับประกันโดยมาตรฐาน C++ (อย่างน้อย 64 บิต) ซึ่งให้ช่วงค่าที่ใหญ่กว่า int, long, หรือ unsigned int มาก

7.
เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คือ 0 (ศูนย์)
เหตุผล:
byte คือ 8-bit unsigned integer: ชนิดข้อมูล byte มีขนาด 8 บิตและเป็นแบบไม่มีเครื่องหมาย (unsigned) นั่นหมายความว่ามันสามารถเก็บค่าได้ตั้งแต่ 0 ถึง 255 เท่านั้น
เกิด Overflow: เมื่อคุณพยายามกำหนดค่า 256 ซึ่งเกินขีดจำกัดสูงสุด 255 มันจะเกิด Integer Overflow
การวนกลับ (Wrapping Around): ค่าจะ "วนกลับ" ไปที่จุดเริ่มต้นของช่วงนั้นๆ (0). ลองคิดภาพเหมือนวงล้อที่นับจาก 0 ถึง 255 แล้วพอนับเกิน 255 ก็จะกลับมาที่ 0 ใหม่.
255 + 1 = 256
เมื่อ byte เก็บได้สูงสุดแค่ 255 การบวก 1 เข้าไปจึงทำให้ค่าวนกลับไปที่ 0 ครับ
