คำถาม

1.
1.1 int บน ESP32 ใช้กี่ไบต์?
ชนิดข้อมูล int จะใช้ 4 ไบต์ (32 บิต)
ขอบเขตของค่า int จะอยู่ที่ -2,147,483,648 ถึง 2,147,483,647

1.2 จากผลลัพธ์ นักศึกษาสังเกตเห็นอะไรเมื่อค่าเกินขอบเขตของ int บน ESP32?
float ใช้ 4 ไบต์
double ใช้ 8 ไบต์

2.
2.1float และ double บน ESP32 ใช้กี่ไบต์ตามลำดับ?
float: ใช้ 4 ไบต์ (32 บิต)
double: ใช้ 8 ไบต์ (64 บิต)

2.2นักศึกษาสังเกตเห็นความแตกต่างของความแม่นยำระหว่าง float และ double อย่างไร? สถานการณ์ใดที่คุณควรเลือกใช้ double แทน float?
float: เป็นชนิดข้อมูลทศนิยมแบบ Single Precision (32 บิต) ให้ความแม่นยำประมาณ 6-7 ตำแหน่งทศนิยม ซึ่งหมายความว่าหลังจากตำแหน่งที่ 7 เป็นต้นไป ค่าที่ได้อาจจะไม่ถูกต้องหรือคลาดเคลื่อนจากค่าจริง
double: สำหรับ ESP32, double เป็นชนิดข้อมูลทศนิยมแบบ Double Precision (64 บิต) ซึ่งให้ความแม่นยำที่สูงกว่า float อย่างแท้จริง คือประมาณ 15-17 ตำแหน่งทศนิยม
ควรเลือกใช้ double แทน float ในสถานการณ์ที่:
1.การคำนวณต้องการความแม่นยำสูงมาก:
เช่น การคำนวณทางวิทยาศาสตร์, วิศวกรรม, ฟิสิกส์, การเงิน, หรือการนำทาง ที่การปัดเศษเพียงเล็กน้อยอาจส่งผลให้เกิดความผิดพลาดขนาดใหญ่ในผลลัพธ์สุดท้าย
การคำนวณที่ต้องทำซ้ำๆ หลายครั้ง (iterative calculations) เพราะข้อผิดพลาดจากการปัดเศษของ float จะสะสมและทำให้ผลลัพธ์คลาดเคลื่อนมากขึ้นเรื่อยๆ แต่ double จะลดปัญหานี้ได้ดีกว่า
2.ความเข้ากันได้ของโค้ด (Code Portability) เป็นสิ่งสำคัญ:
หากคุณกำลังพัฒนาโค้ดที่อาจจะต้องนำไปรันบนแพลตฟอร์มอื่น ๆ (เช่น คอมพิวเตอร์ส่วนบุคคลหรือเซิร์ฟเวอร์) ที่ double เป็น 64 บิตและให้ความแม่นยำสูงอยู่แล้ว การใช้ double ตั้งแต่แรกจะช่วยให้โค้ดของคุณสามารถพอร์ตย้ายและทำงานได้อย่างถูกต้องบนแพลตฟอร์มเหล่านั้นได้ง่ายขึ้น โดยไม่ต้องแก้ไขชนิดข้อมูลในภายหลัง
3.หน่วยความจำไม่ใช่ข้อจำกัดสำคัญ:
การใช้ double จะใช้หน่วยความจำมากกว่า float สองเท่า (8 ไบต์ vs 4 ไบต์) ดังนั้น หากโปรเจกต์ของคุณมีข้อจำกัดด้านหน่วยความจำอย่างรุนแรง อาจต้องพิจารณาอย่างรอบคอบ แต่โดยทั่วไปแล้วบน ESP32 ที่มี RAM ค่อนข้างมาก การใช้ double ไม่ได้เป็นปัญหาใหญ่มากนักถ้าความแม่นยำคือสิ่งที่คุณต้องการ

3.
3.1char ใช้กี่ไบต์? ค่าตัวเลข (ASCII value) มีความสัมพันธ์กับอักขระอย่างไร?
char ใช้ 1 ไบต์ (8 บิต) บน ESP32
อักขระทุกตัวจะถูกแทนด้วย ค่าตัวเลขจำนวนเต็มเฉพาะตัว ที่เรียกว่ารหัส ASCII (หรือ Unicode) ซึ่งคอมพิวเตอร์ใช้ในการจัดเก็บ ประมวลผล และแสดงผล. char คือชนิดข้อมูลที่เก็บค่าตัวเลข ASCII เหล่านี้ไว้

4.
4.1bool ใช้กี่ไบต์? true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
-bool ใช้กี่ไบต์? true และ false ถูกแสดงผลเป็นค่าใดบน Serial Monitor?
 -ชนิดข้อมูล bool ใช้ 1 ไบต์ บน ESP32
 -บน Serial Monitor: true จะถูกแสดงผลเป็น 1 และ false จะถูกแสดงผลเป็น 0

5.
5.1ชนิดข้อมูลจำนวนเต็มแต่ละชนิด (long, long long, unsigned int, unsigned long, unsigned long long) ใช้กี่ไบต์บน ESP32?
-long: 4 ไบต์ (32 บิต)
-long long: 8 ไบต์ (64 บิต)
-unsigned int: 4 ไบต์ (32 บิต)
-unsigned long: 4 ไบต์ (32 บิต)
-unsigned long long: 8 ไบต์ (64 บิต)

5.2บน ESP32, long มีขอบเขตเท่ากับ int หรือไม่? ชนิดข้อมูลใดที่คุณจะใช้หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด?
-บน ESP32 ซึ่งเป็นไมโครคอนโทรลเลอร์แบบ 32 บิต ชนิดข้อมูล long และ int มีขนาดเท่ากันคือ 4 ไบต์ (32 บิต) และมีขอบเขตของค่าที่เท่ากันคือ: -2,147,483,648 ถึง 2,147,483,647
-หากต้องการเก็บค่าจำนวนเต็มบวกที่ใหญ่ที่สุด ควรใช้ชนิดข้อมูล unsigned long long ซึ่งมีขนาด 8 ไบต์ (64 บิต) และรองรับค่าตั้งแต่ 0 ถึง 18,446,744,073,709,551,615

6.
6.1byte ใช้กี่ไบต์? เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์ที่ได้คืออะไร และเพราะเหตุใด?
-byte ใช้ 1 ไบต์ (8 บิต)
-เมื่อ myByte ถูกกำหนดให้เป็น 256 ผลลัพธ์คือ 0 (ศูนย์)
เหตุผล: เนื่องจาก byte เป็นชนิดข้อมูลแบบ 8 บิตที่ไม่มีเครื่องหมาย (unsigned) จึงสามารถเก็บค่าได้ตั้งแต่ 0 ถึง 255 เท่านั้น การใส่ค่า 256 ทำให้เกิด Integer Overflow (การล้น) และค่าจะ "วนกลับ" (wrap around) ไปเริ่มต้นที่ 0 ครับ

7.
7.1ทำไม 10 / 3.0 (เมื่อตัวหารเป็น float หรือ double) ถึงได้ผลลัพธ์เป็นทศนิยม แต่เมื่อตัวหารถูกแปลงเป็น int แล้วผลลัพธ์เป็นจำนวนเต็ม?
-10 / 3.0 (เมื่อตัวหารเป็น float/double): นี่คือ "การหารแบบทศนิยม" หรือ Floating-Point Division
 -เหตุผล: เนื่องจากมีตัวถูกหารหรือตัวหารอย่างน้อยหนึ่งตัวเป็นชนิดข้อมูลทศนิยม (float หรือ double) ตัวเลขจำนวนเต็มจะถูก Type Promotion (เลื่อนขั้นชนิดข้อมูล) เป็นทศนิยมก่อนการคำนวณ ทำให้การหารทั้งหมดเป็นการคำนวณแบบทศนิยมและได้ผลลัพธ์เป็นทศนิยม (เช่น 3.33)
-10 / (int)3.0 (เมื่อตัวหารถูกแปลงเป็น int): นี่คือ "การหารแบบจำนวนเต็ม" หรือ Integer Division
 -เหตุผล: เนื่องจาก 3.0 ถูก Type Casting (แปลงชนิดข้อมูล) เป็น int อย่างชัดเจน ((int)3.0 กลายเป็น 3) ทำให้การคำนวณเป็นการหารระหว่างจำนวนเต็ม (10 / 3)
 -ในการหารจำนวนเต็ม ผลลัพธ์ที่ได้จะเป็นจำนวนเต็มเสมอ โดยส่วนที่เป็นทศนิยมจะถูก ตัดทิ้ง (truncation) ไม่มีการปัดเศษขึ้นหรือลง ทำให้ผลลัพธ์เป็น 3

8.
8.1นักศึกษาจะใช้การทำ Type Casting ในสถานการณ์ใดบ้างในการเขียนโปรแกรม?
1.เพื่อให้ได้ผลลัพธ์ทศนิยมที่แม่นยำในการหารจำนวนเต็ม:
เช่น การคำนวณค่าเฉลี่ยหรือเปอร์เซ็นต์ โดยแปลงตัวเลขจำนวนเต็มอย่างน้อยหนึ่งตัวให้เป็น float หรือ double ก่อนการหาร (ตัวอย่าง: (float)7 / 20) เพื่อป้องกัน Integer Division ที่จะตัดทศนิยมทิ้ง
2.เพื่อแปลงค่าระหว่างชนิดข้อมูลต่าง ๆ:
เช่น แปลง float เป็น int เพื่อ ตัดทศนิยม ทิ้ง (ตัวอย่าง: (int)temperatureCelsius)
หรือแปลง int เป็น float/double เพื่อใช้ในการคำนวณที่ต้องการทศนิยมโดยไม่เกิด Integer Division
3.เพื่อจัดการกับค่า ASCII/Unicode ของอักขระ:
เพื่อแสดงค่าตัวเลข ASCII ของอักขระ (ตัวอย่าง: (int)myChar)
หรือเพื่อกำหนดค่าตัวเลข ASCII ให้กับตัวแปร char แล้วให้แสดงเป็นอักขระ
4.เมื่อเรียกใช้ฟังก์ชันหรือไลบรารีที่ต้องการชนิดข้อมูลเฉพาะ:
เพื่อให้พารามิเตอร์ที่ส่งไปตรงกับชนิดข้อมูลที่ฟังก์ชันคาดหวัง หรือเพื่อให้ค่าที่ฟังก์ชันส่งกลับมาถูกเก็บในชนิดข้อมูลที่เหมาะสม
5.เพื่อควบคุมและป้องกันข้อผิดพลาดจาก Implicit Conversion (การแปลงโดยนัย):
เป็นการบอก Compiler ว่าเราตั้งใจที่จะแปลงชนิดข้อมูลนั้นๆ แม้ว่าอาจมีการสูญเสียข้อมูลเกิดขึ้น (เช่น การตัดทศนิยม) เพื่อหลีกเลี่ยง Warning หรือ Error
